## This module improves upon the Nixpkgs module by using better
## typesafety, requiring peer PSKs, and ensuring that PSKs and private
## keys aren't written to the Nix store.

{ config, lib, pkgs, ... }:

with lib;

let

  cfg = config.networking.wireguard;
  keys = config.quixops.keychain.keys;

  kernel = config.boot.kernelPackages;

  stateDir = "/var/lib/wireguard";
  keyName = name: "wireguard-${name}-key";
  pskName = name: peer: "wireguard-${name}-${peer}-psk";

  # interface options

  interfaceOpts = { name, ... }: {

    options = {

      ips = mkOption {
        example = [ "192.168.2.1/24" "2001:DB8::1:0/112" ];
        default = [];
        type = types.listOf (types.either pkgs.lib.types.ipv4CIDR pkgs.lib.types.ipv6CIDR);
        description = "The IP addresses of the interface.";
      };

      privateKeyLiteral = mkOption {
        type = pkgs.lib.types.nonEmptyStr;
        example = "<key>";
        description = ''
          The WireGuard server's private key, as a string literal, as
          generated by the command <command>wg genkey</command>. Note that
          this secret will not be copied to the Nix store. However, uppon
          start-up, the service will copy a file containing the key to its
          persistent state directory.
        '';
      };

      listenPort = mkOption {
        default = null;
        type = with types; nullOr pkgs.lib.types.port;
        example = 51820;
        description = ''
          UDP port for listening. Optional; if not specified,
          automatically generated based on interface name.
        '';
      };

      preSetup = mkOption {
        example = literalExample ''
          ${pkgs.iproute}/bin/ip netns add foo
        '';
        default = "";
        type = with types; coercedTo (listOf str) (concatStringsSep "\n") lines;
        description = ''
          Commands called at the start of the interface setup.
        '';
      };

      postSetup = mkOption {
        example = literalExample ''
          printf "nameserver 10.200.100.1" | ${pkgs.openresolv}/bin/resolvconf -a wg0 -m 0
        '';
        default = "";
        type = with types; coercedTo (listOf str) (concatStringsSep "\n") lines;
        description = "Commands called at the end of the interface setup.";
      };

      postShutdown = mkOption {
        example = literalExample "${pkgs.openresolv}/bin/resolvconf -d wg0";
        default = "";
        type = with types; coercedTo (listOf str) (concatStringsSep "\n") lines;
        description = "Commands called after shutting down the interface.";
      };

      table = mkOption {
        default = "main";
        type = pkgs.lib.types.nonEmptyStr;
        description = ''The kernel routing table to add this interface's
        associated routes to. Setting this is useful for e.g. policy routing
        ("ip rule") or virtual routing and forwarding ("ip vrf"). Both numeric
        table IDs and table names (/etc/rt_tables) can be used. Defaults to
        "main".'';
      };

      peers = mkOption {
        default = {};
        description = "Peers linked to the interface.";
        type = types.attrsOf pkgs.lib.types.wgPeer;
      };

      allowedIPsAsRoutes = mkOption {
        example = false;
        default = true;
        type = types.bool;
        description = ''
          Determines whether to add allowed IPs as routes or not.
        '';
      };
    };

  };

  generateUnit = name: values:
    nameValuePair "wireguard-${name}"
      {
        description = "WireGuard Tunnel - ${name}";
        wants = [ "keys.target" ];
        requires = [ "network-online.target" ];
        after = [ "network.target" "network-online.target" "keys.target" ];
        wantedBy = [ "multi-user.target" ];
        environment.DEVICE = name;
        path = with pkgs; [ kmod iproute wireguard-tools ];

        serviceConfig = {
          Type = "oneshot";
          RemainAfterExit = true;
        };

        script =
        let
          keyPath = keys."${keyName name}".path;
        in
        ''
          modprobe wireguard

          ${values.preSetup}

          ip link add dev ${name} type wireguard

          ${concatMapStringsSep "\n" (ip:
            "ip address add ${ip} dev ${name}"
          ) values.ips}

          wg set ${name} private-key ${keyPath} ${
            optionalString (values.listenPort != null) " listen-port ${toString values.listenPort}"}

          ${concatMapStringsSep "\n" (peer:
            let pskPath = keys."${pskName name peer.name}".path;
            in
              "wg set ${name} peer ${peer.publicKey}" +
              " preshared-key ${pskPath}" +
              optionalString (peer.endpoint != null) " endpoint ${peer.endpoint}" +
              optionalString (peer.persistentKeepalive != null) " persistent-keepalive ${toString peer.persistentKeepalive}" +
              optionalString (peer.allowedIPs != []) " allowed-ips ${concatStringsSep "," peer.allowedIPs}"
            ) (mapAttrsToList (_: peer: peer) values.peers)}

          ip link set up dev ${name}

          ${optionalString (values.allowedIPsAsRoutes != false) (concatStringsSep "\n" (concatMap (peer:
              (map (allowedIP:
                "ip route replace ${allowedIP} dev ${name} table ${values.table}"
              ) peer.allowedIPs)
            ) (mapAttrsToList (_: peer: peer) values.peers)))}

          ${values.postSetup}
        '';

        postStop = ''
          ip link del dev ${name}
          ${values.postShutdown}
        '';
      };

in

{

  disabledModules = [ "services/networking/wireguard.nix" ];

  ###### interface

  options = {

    networking.wireguard = {

      interfaces = mkOption {
        description = "Wireguard interfaces.";
        default = {};
        example = {
          wg0 = {
            ips = [ "192.168.20.4/24" ];
            privateKeyLiteral = "yAnz5TF+lXXJte14tji3zlMNq+hd2rYUIgJBgB3fBmk=";
            peers.demo =
              { allowedIPs = [ "192.168.20.1/32" ];
                presharedKeyLiteral = "tSOLSmehg25TvZghw4R2uIgDrkXh0PEvDupZcXrRNEc=";
                publicKey  = "xTIBA5rboUvnH4htodjb6e697QjLERt1NAB4mZqp8Dg=";
                endpoint   = "demo.wireguard.io:12913"; };
          };
        };
        type = with types; attrsOf (submodule interfaceOpts);
      };

    };

  };


  ###### implementation

  config = mkIf (cfg.interfaces != {}) {

    quixops.assertions.moduleHashes."services/networking/wireguard.nix" =
      "5ecebd36bc4c694d9126f06ca6a6bb0445c9ebd46a9344ea9bb7959d531b6da4";

    boot.extraModulePackages = [ kernel.wireguard ];
    environment.systemPackages = [ pkgs.wireguard-tools ];

    systemd.services = (mapAttrs' generateUnit cfg.interfaces);

    quixops.keychain.keys = listToAttrs (filter (x: x.value != null) (
      (mapAttrsToList
        (ifname: values: nameValuePair (keyName ifname) ({
          destDir = stateDir;
          text = values.privateKeyLiteral;
        })) cfg.interfaces) ++
      (lib.flatten
        (mapAttrsToList
          (ifname: values:
            mapAttrsToList
              (peer: values: nameValuePair (pskName ifname peer) ({
                destDir = stateDir;
                text = values.presharedKeyLiteral;
              }))
              values.peers)
          cfg.interfaces))
      ));

  };

}
